import * as core from '@actions/core';
import {Octokit} from '@octokit/rest';
import {config} from 'dotenv';
import {resolve} from 'path';
import * as chromeLauncher from 'chrome-launcher';
import * as lighthouse from 'lighthouse';
import {Flags} from 'lighthouse/types/externs';

// Load environment variables
config({path: resolve(__dirname, '../.env')});

interface ActionInputs {
  GH_TOKEN: string;
  GIST_ID: string;
  TEST_URL: string;
  PRINT_SUMMARY: boolean;
  RESULT_BADGE: boolean;
}

const ACTION_URL = 'https://github.com/marketplace/actions/lighthouse-box';
const inputs: ActionInputs = {
  GH_TOKEN: core.getInput('GH_TOKEN', {required: true}),
  GIST_ID: core.getInput('GIST_ID', {required: true}),
  TEST_URL: core.getInput('TEST_URL', {required: true}),
  PRINT_SUMMARY: core.getBooleanInput('PRINT_SUMMARY', {required: true}),
  RESULT_BADGE: core.getBooleanInput('RESULT_BADGE', {required: true}),
};

function getCurrentDate(): string {
  return new Date().toLocaleDateString('en-us', {day: 'numeric', year: 'numeric', month: 'short'});
}

const UPDATE_DATE: string = getCurrentDate();
const summaryTable: any[] = [];
const GIST_TITLE = `My website [update ${UPDATE_DATE}]`;

async function fetchMetrics(testUrl: string): Promise<lighthouse.RunnerResult> {
  const chrome = await chromeLauncher.launch({chromeFlags: ['--headless']});
  const OPTIONS: Flags = {logLevel: 'info', output: 'json', port: chrome.port};
  const runnerResult = await lighthouse(testUrl, OPTIONS);
  await chrome.kill();
  return runnerResult;
}

function generateGistContent(runnerResult: lighthouse.RunnerResult): string {
  const {categories} = runnerResult.lhr;
  const metrics = {
    performance: categories.performance.score * 100,
    accessibility: categories.accessibility.score * 100,
    bestPractices: categories['best-practices'].score * 100,
    seo: categories.seo.score * 100,
    pwa: categories.pwa.score * 100,
  };
  summaryTable.push([{data: 'Category', header: true}, {data: 'Result', header: true}]);
  return Object.entries(metrics).map(([category, score]) => {
    summaryTable.push([category, `${score}%`]);
    let badge = 'üôâ';
    if (score > 80) badge = 'ü•à';
    if (score > 90) badge = 'ü•á';
    if (score === 100) badge = 'üèÜ';
    const title = `${category}:`.padEnd(inputs.RESULT_BADGE ? 37 : 49, '.');
    const percent = `${score}%`.padStart(4, '.');
    const result = inputs.RESULT_BADGE ? ` ${badge}`.padStart(11, '.') : '';
    return `${title}${percent}${result}`;
  }).join('\n');
}

async function updateGistContent(gistId: string, content: string): Promise<void> {
  const octokit = new Octokit({auth: inputs.GH_TOKEN});
  try {
    const gist = await octokit.gists.get({gist_id: gistId});
    const filename = Object.keys(gist.data.files || {})[0];
    if (!filename) {
      core.setFailed('Action failed: Gist filename not found');
      return;
    }
    await octokit.gists.update({
      gist_id: gistId,
      files: {[filename]: {filename: GIST_TITLE, content}},
    });
  } catch (error: any) {
    core.setFailed(`Action failed: Gist ${error.message}`);
  }
}

async function printLighthouseSummary(runnerResult: lighthouse.RunnerResult): Promise<void> {
  const summary = core.summary
    .addHeading('Results')
    .addTable(summaryTable)
    .addBreak()
    .addRaw('Lighthouse metrics for ')
    .addLink(runnerResult.lhr.mainDocumentUrl, runnerResult.lhr.mainDocumentUrl)
    .addRaw(' generated by ')
    .addLink('lighthouse-box/1.1', ACTION_URL);
  if (inputs.PRINT_SUMMARY) {
    await summary.write();
  } else {
    console.log(summary.stringify());
  }
}

(async () => {
  const runnerResult = await fetchMetrics(inputs.TEST_URL);
  const gistContent = generateGistContent(runnerResult);
  await updateGistContent(inputs.GIST_ID, gistContent);
  await printLighthouseSummary(runnerResult);
})();
